# crypto_netsec_hw3
This is my repository for the third CSCI-4230 homework taught by Professor Yener at RPI.

# The Answers
1. For the ciphertext, I got the following results: the result I got for the ciphertext was 721287 (in decimal), which is 10110000000110000111 in binary. 
2. The results were verified by writing a decryption function titled message_decryption() that takes some of the values that were given. It also took the answer from number one and then runs the Blum-Goldwasser decryption part to get the values. The results can be seen in the code, with a boolean statement checking if the decrypted message and the given message are the same. For reference, the given plaintext is 639244 with the binary representation being 10011100000100001100. 

# The Algorithm
This homework tested our ability to encode the Blum-Goldwasser crypto scheme. The algorithm was written by following the steps in this Wikipedia page: https://en.wikipedia.org/wiki/Blum%E2%80%93Goldwasser_cryptosystem

First, the message was encrypted in order to generate the ciphertext. Two functions were defined in order to help with this. First, a key_generation() functions was defined in order to generate the public N. N is composed of two numbers p and q which are congruent to 3 mod 4 i.e. they are Blum integers. This is why this cryptosystem works in the first place! If p and q are not given, then a p and q are generated at random. They are multiplied together and produce N.

After that, a message_encryption() function is used. This was written to take the message to encrypt, the generated N, and possibly an x_0 value as parameters. Professor Yener was nice enough to give us an x_0 value, but my function accounts for if one is not provided, then one will be generated. After that, it's pretty much the algorithm described in Wikipedia. L is defined to be the length of the messages, and then the bits b are defined and computed based on the least significant bits of x_i, with x_0 being defined and x_i changing to be itself squared mod n. After that, the bits of m and b are XOR'd to generate the cipher. 

This cipher is returned and then verified with the following message_decryption() function. This function takes in the ciphertext, the given p and q, the given a and b, and the generated N. One assumption that was made for this project was that the bits would be 20-bits, as that was what was given to us. Therefore, all messages sent between a hypothetical Alice and Bob are 20-bits (though this can be changed to a general case if so desired). Afterward, L is defined in the same way as message encryption. Then, r_p and r_q are defined according to the algorithm. Again, x_0 is given to us but one is generated just in case. a and b are given by Professor Yener and are the inverses such that ap + bq = 1; a and b are the modulo inverses of p and q. This is needed when generated x_0. They can be easily found with some functions defined before the key_generation(), but it is not needed as a and b are given. If they were not, they would be calculated with these functions. b is calculated in the same way as it was for the message_encryption(), and then the bits of the cipher and b bits are XOR'd. The resulting bits are returned and compared to ensure they are the same as the given message.

# Overall thoughts
This is a cool algorithm! The overall cool part is how they are super dependent on the Blum integers. Makes you think how Blum came up with those integers in the first place. I'm interested in seeing how this is going to be used in future projects! 